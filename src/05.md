# setup <div id="vue-setup"></div>

這邊開始介紹一下 setup ( Composition API ) 與 Options API 不一樣的地方，在 setup()裡通常都有包含 Lifecycle Hooks( 生命週期鉤子 )、狀態資料等，但有些程式邏輯不一定都要在這裡面做定義，可以透過引入( import )的方式來使用，但透過 setup（）函式需要透過 return 回傳回去。

```javascript=
// 定義玩參數要回傳出去，才能在template模板使用！
export default {
    setup(props) {
        const text = '文字...'
        return { text }
    }
}
```

> 在這邊需要中在 setup()函式裡面，避免使用"this"，會找不到組建實例，如同[生命週期的範例](src/../03.md)，setup()函式的調用在 beforeCreate、created 的前面，簡單來說 setup()函式在組件解析之前就被調用，所以"this"會無法在 setup 中獲取！！

## props : <div id="vue-props"></div>

> 1. props 為 setup()函式第一個參數，要調用 props 時需要透過 props 來取的相對應 props 的內容。
> 2. props 可以在 setup()函式中解構出來，但是會消除 prop 響應式特性，如果需要解構，需使用[toRefs]()來操作。

```
export default {
    props:{
        type: String,
        default:"normal"
    },
    setup(props,context) {

        console.log(props,type)
        return {}
    }
}
```

## context : <div id="vue-context"></div>

> context 為 setup()函式第二個參數 Object，可以透過解構的方式取出 attrs、slots、emit、expose

```
export default {
    setup(props,{ attrs, slots, emit, expose }) {
        console.log('emit => ',emit)
        console.log('attrs => ',attrs)
        return {}
    }
}
```

## context / emit : <div id="vue-emits"></div>

Vue3 中使用 emit 需要事在 emits 選項定義名稱。

```javascript=
// 子組件
<template>
  <button @click="emitHandler">出發emit事件</button>
</template>

<script>
export default {
  name: "TestComponent",
  // 數用陣列的方式，帶入emit事件名稱
  emits: ["callEmit"],
  setup(props, { emit }) {
    const emitHandler = () => {
      emit("callEmit");
    };
    return { emitHandler };
  },
};
</script>
```

```javascript=
// 父組件
<template>
  // 在父層監聽emit事件
  <TestComponent @call-emit="emitHandler"></TestComponent>
</template>

<script>
import TestComponent from "./components/Test.vue";
export default {
  name: "App",
  components: {
    TestComponent,
  },
  setup() {
    const emitHandler = () => {
      alert("接收emit");
    };
    return { emitHandler };
  },
};
</script>
```

> emit 的事件驗證 : 這邊需注意的事，如果 emit 驗證失敗會在 devtools 顯示 warn 提示訊息，但是值也是會傳上去到父層( 簡單來說就算在 emit 觸發失敗，一樣會再父層接收到 emit 事件，並不會因此而停止呼叫！ )。

```javascript=
// 子組件
<template>
  <button @click="emitHandler">出發emit事件</button>
</template>

<script>
export default {
  name: "TestComponent",
  // 改用物件的型式，參數是一個函式
  emits: {
    callEmit(val){
      if (!val) {
        return false;
      }
      return true;
    },
  },
  setup(props, { emit }) {
    const emitHandler = () => {
      emit("callEmit", 0);
    };
    return { emitHandler };
  },
};
</script>
```

```javascript=
// 父組件
<template>
  <TestComponent @call-emit="emitHandler"></TestComponent>
</template>

<script>
import TestComponent from "./components/Test.vue";
export default {
  name: "App",
  components: {
    TestComponent,
  },
  setup() {
    // emit驗證失敗，還是會收到回傳值，但多了devtools的warn驗證失敗的提示訊息
    const emitHandler = (val) => {
      alert(`接收emit: ${val}`);
    };
    return { emitHandler };
  },
};
</script>
```

## context / expose : <div id="vue-expose"></div>

expose 這個函數，主要是限制該組件會暴露出去的資料，可以限制組件向外暴露的資料來維持組件的封裝性

> 以下範例為 ： 不使用 expose 函式，在父層透過 ref 就能取得子組件的任何資料

```javascript=
// 子組件
<script>
export default {
  name: "TestComponent",
  setup() {
    const text = "TestComponent";
    return {};
  },
};
</script>
```

```javascript=
// 父組件
<script>
import { onMounted, ref } from "vue";
import TestComponent from "./components/Test.vue";
export default {
  name: "App",
  components: {
    TestComponent,
  },
  setup() {
    const getDom = ref(null);
    // 成功取得到子組件的資料
    onMounted(() => {
      console.log("取得子組件text資料 :", getDom.value.text);
    });
    return { getDom };
  },
};
</script>
```

> 使用 expose 指定想暴露出去的資料 : 當設定 expose 後，父子層只能拿去 expose 所指定的值，其他的值接無法獲取！

```javascript=
// 子組件
<script>
export default {
  name: "TestComponent",
  setup(props, { expose }) {
    const text = "TestComponent";
    const count = 1;
    // 這邊指定義text可暴露在外，count只能在該組件內部使用，外部(父層無法取得expose以外的直)
    expose({ text });
    return { text, count };
  },
};
</script>
```

```javascript=
// 父組件
<script>
import { onMounted, ref } from "vue";
import TestComponent from "./components/Test.vue";
export default {
  name: "App",
  components: {
    TestComponent,
  },
  setup() {
    const getDom = ref(null);
    onMounted(() => {
      console.log("取得子組件text資料 :", getDom.value.text); // 回傳 : TestComponent
      console.log("取得子組件count資料 :", getDom.value.count);// 回傳 : undefined
    });
    return { getDom };
  },
};
</scrip>
```

## setup - ref、reactive <div id="vue-ref_reactive"></div>

在 Vue2 裡，要綁定值都會寫在 data 裡面，如果不想給 Vue 綁定，都會寫在 data 的外面，到 Vue3 的 setup 函式裡可以很輕鬆定義需要被 Vue 綁定的資料，或不需要被 Vue 綁定的資料，而<span style="color:red;">ref</span>、<span style="color:red;">reactive</span>，就是用來跟 Vue 做響應式綁定的函式。

> ref :  可以包裝原始型別（ Primitive ）的值之外，也可以來包裝物件或陣列，要使用被 ref 包裝的資料，需要在後面加上.value，才能取得被 ref 包裝的值！

```javascript=
import { ref } from "vue";
export default {
  name: "App",
  setup() {
    const num = ref(0);
    setTimeout(() => num.value++, 1000);

    // 定義完ref之後的值，需要返回出去才能在模板時候，在模板使用不需要加上.value
    return { num };
  },
};
```

> ref 存取 DOM 元素 : 在 setup()函式裡，沒有 this.$refs(也沒有 this)，所以綁定 DOM 的方式：

```javascript=
<template>
  // 要與要綁定的變數同名！ ---- (3)
  <div ref="getDom"></div>
</template>

<script>
import { ref, onMounted } from "vue";
export default {
 name: "App",
 setup() {

   // 聲明一個要被綁定的dom名稱 ---- (1)
   const getDom = ref(null);

   onMounted(() => {
    // 當生命週期onMounted的時候就能看到，DOＭ已被getDom存取 ---- (4)
     console.log("getDom -->", getDom);
   });

   // 並return出去，在模板中需要定義ref="getDom"同名的屬性 ---- (2)
   return { getDom };
 },
};
</script>
```

> reactive : <span style="color:red;">reactive()</span> 是 ref()以外，另一個可以包裝成響應式物件的函式，包裝過後的<span style="color:red;">reactive()</span>會回傳被 Proxy 所代理的物件，<span style="color:red;">reactive()</span>函式只能包裝<span style="color:red;"> 物件、陣列 </span>，使用上不需要加上.value，就如取得物件實字的 value 一樣。

```javascript=
import { reactive, onMounted } from "vue";
export default {
  name: "App",
  setup() {
    const data = reactive({ num: 1 });

    onMounted(() => {
      // 不需要加上.value，取值方式就與物件實字方式一樣！
      console.log("data -->", data.num);
    });
    return { data };
  },
};
```

> <span style="color:red;">reactive()</span> 可以包裝物件跟陣列，所以我們也可以利用解構的方式，方便取的屬性值，如果使用解構的方式取直，會把值從響應式的狀態抽取出來 :

```javascript=
<template>
  <div>{{ num }}</div>
  <button type="button" @click="num++">+1</button>
</template>

<script>
import { reactive } from "vue";
export default {
  name: "App",
  setup() {
    const data = reactive({ num: 1 });
    // 這邊使用解構得方式，可以看到在案+1的時候，畫面卻沒更新
    return { ...data };
  },
};
</script>
```

> 想要解決以上的問題看使用 toRefs()函式：

```javascript=
<template>
  <div>{{ num }}</div>
  <button type="button" @click="num++">+1</button>
</template>

<script>
import { reactive, toRefs } from "vue";
export default {
  name: "App",
  setup() {
    const data = reactive({ num: 1 });

    // or

    // const refData = toRefs(data);

    // 使用toRefs()的方式，可以看到在案+1的時候，畫面有更新
    return { ...toRefs(data) /*  or ...refData  */ };
  },
};
</script>
```

## methods : <div id="vue-methods"></div>

在 setup()函式裡，不在提供 "method" 屬性，而是直接在 setup()裡定義一個 function (表達式或陳述式)，如果函式不需要在模板內使用可以不用 return 回去！

```javascript=
export default {
    setup(props,{ attrs, slots, emit, expose }) {
        // 表達式
        const call1 = () => console.log('Hi')

        // or

        // 陳述式
        function call2(){
            console.log('Hi')
        }

        // 如果模板內需要使用，要return回去！
        return { call1 , call2}
    }
}
```

## computed : <div id="vue-computed"></div>

使用 computed 需要從 vue 提取出來，並使用函數式的方式使用。

```javascript=
import { ref ,computed } from 'vue'
export default {
  setup() {
    const num = ref(0)
    const double = computed(() => num.value * 2)
    return { double }
  }
}
```

## watch / watchEffect ( Vue3 新增 ) : <div id="vue-watch_watchEffect"></div>

使用 watch / watchEffect 的方式，就跟 computed 一樣需要從 vue 提取出來，並函數式的方式使用，使用方式與 Vue2 的寫法稍微不同。

> watch : 可以偵聽 <span style="color:red;">單個資料</span> 或 <span style="color:red;">多個資料</span> (把需要監聽的資料放入陣列裡)<br>

```
參數為：
1. 第一個參數 : 要監控的值
2. 第二個參數 : 當值被改變時觸發的callback函式，callback函式自帶(原始值/已變更的直)
3. 第三個參數 :  { deep: true } 深度檢查的時候，如物件包物件（嵌套對象），預設為false
```

```javascript=
// 偵聽一個資料
import { ref, watch } from "vue";
export default {
  setup() {
    const num = ref(0);

    // 使用watch監聽
    watch(num, (newVal, oldVal) => {
      console.log("newVal :", newVal, " ", "oldVal :", oldVal);
    });

    // 使用setTimeout方式來測式，一秒過後watch會偵聽改動部分
    setTimeout(() => {
      num.value++;
    }, 1000);

    return {};
  },
};
```

```javascript=
// 偵聽多個資料
import { ref ,watch  } from "vue";
export default {
  name: "App",
  setup() {
    const text1 = ref("");
    const text2 = ref("");

    watch([text1, text2], (newVal, oldVal) => {
      // 回傳陣列的直
      console.log("newVal : ", newVal, "", "o :", oldVal);
    });

    text1.value = 1;
    text2.value = 2;
    return {};
  },
};
```

> 1. 如果是監聽<span style="color:red;">reactive（響應式）</span>的資料，第一個參數需要透過 return 函式 的方式監聽，這邊需要注意的事，監聽<span style="color:red;">reactive</span>的其中一個屬性，如果沒使用 return 函式 的方式去監聽，會沒有反應！
> 2. 直接監聽整個<span style="color:red;">reactive</span>資料(需加上 deep：true 才會有反應)，會發現第二參數回傳的 newValue、oldValue 值都顯示一樣！！

```javascript=
import { reactive, watch } from "vue";
export default {
  name: "App",
  setup() {
    const data = reactive({ num: 1 });

    // 這邊沒有反應
    watch(data.num, (newVal, oldVal) => {
      console.log("watch-1 newVal : ", newVal, "", "o :", oldVal);
    });

    // 回傳的參數都會一樣
    watch(data, (newVal, oldVal) => {
      console.log("watch-2 newVal : ", newVal, "", "o :", oldVal);
    });

    // 正確寫法為
    watch(
      () => data.num,
      (newVal, oldVal) => {
        console.log("watch-3 newVal : ", newVal, "", "o :", oldVal);
      }
    );

    data.num++;
    return {};
  },
};
```

> <span style="color:red;">watchEffect</span> 與 watch 一樣都是在監控值，然後執行裡面的程式碼，但比較不同的是<span style="color:red;">watchEffect</span>不用特地指定要監控的資料，而是當 setup()函式內部 callback 對應的響應式資料被更新時，就會觸發( 簡單來說監控 setup 裡面的值被更新時，都會觸發 )，另外<span style="color:red;">watchEffect</span>是在 setup()函式剛被建立後就會<span style="color:red;">立即執行一次</span>！

```javascript=
import { ref, watchEffect } from "vue";
export default {
  name: "App",
  setup() {
    const num = ref(0);

    // setup剛被建立完，立即執行一次
    watchEffect(() => console.log("num", num.value));

    // 過一秒後更改num值，會在觸發一次watchEffect
    setTimeout(() => num.value++, 1000);

    return {};
  },
};
</script>
```

> 如果不是使用 <span style="color:red;">ref</span> 或 <span style="color:red;">reactive</span> 函式把值包裝起來的變數，當 setup()剛被建立時會執行一次 <span style="color:red;">watchEffect</span> ，但在更新值的時候就不再觸發！

```javascript=
import { watchEffect } from "vue";
export default {
  name: "App",
  setup() {
    let num = 0;

    // 會立即執行一次
    watchEffect(() => console.log("num", num));

    // 更改的值不是響應式，所以不再觸發watchEffect
    setTimeout(() => num++, 1000);

    return {};
  },
};
```

> 以上 <span style="color:red;">watchEffect</span>總結：
>
> 1. 不需要特定傳入監控的資料
> 2. setup()被建立完，立即執行
> 3. 只能獲取變化後的值，無法取的變化前的值
