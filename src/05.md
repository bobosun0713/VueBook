# setup <div id="vue-setup"></div>

這邊開始介紹一下 setup ( Composition API ) 與 Options API 不一樣的地方，在 setup()裡通常都有包含 Lifecycle Hooks( 生命週期鉤子 )、狀態資料等，但有些程式邏輯不一定都要在這裡面做定義，可以透過引入( import )的方式來使用，但透過 setup（）函式需要透過 return 回傳回去。

<!--sec data-title="setup 起手式 :" data-id="section1" data-show=true ces-->

```js
// 定義玩參數要回傳出去，才能在template模板使用！
export default {
    setup(props) {
        const text = '文字...'
        return { text }
    }
}
```

<!--endsec-->

> [!warning]
> 在這邊需要中在 setup()函式裡面，避免使用"this"，會找不到組建實例，如同[生命週期的範例](src/../03.md)，setup()函式的調用在 beforeCreate、created 的前面，簡單來說 setup()函式在組件解析之前就被調用，所以"this"會無法在 setup 中獲取！！

## props : <div id="vue-props"></div>
1. props 為 setup()函式第一個參數，要調用 props 時需要透過 props 來取的相對應 props 的內容。
2. props 可以在 setup()函式中解構出來，但是會消除 prop 響應式特性，如果需要解構，需使用[toRefs]()操作來重新綁定響應

<!--sec data-title="props 範例 :" data-id="section2" data-show=true ces-->

```js
export default {
    props:{
        type: String,
        default:"normal"
    },
    setup(props,context) {
        console.log(props,type)
        return {}
    }
}
```

<!--endsec-->




## context : <div id="vue-context"></div>

context 為 setup()函式第二個參數 Object，可以透過解構的方式取出 attrs、slots、emit、expose

<!--sec data-title="context 範例 :" data-id="section3" data-show=true ces-->

```js
export default {
    setup(props,{ attrs, slots, emit, expose }) {
        console.log('emit => ',emit)
        console.log('attrs => ',attrs)
        return {}
    }
}
```

<!--endsec-->




## context / emit : <div id="vue-emits"></div>

Vue3 中使用 emit 需要事在 emits 選項定義名稱。

<!--sec data-title="context / emit 範例 :" data-id="section4" data-show=true ces-->

```xml
// 子組件
<script>
export default {
  name: "TestComponent",
  // 數用陣列的方式，帶入emit事件名稱
  emits: ["callEmit"],
  setup(props, { emit }) {
    const emitHandler = () => {
      emit("callEmit");
    };
    return { emitHandler };
  },
};
</script>

<template>
  <button @click="emitHandler">出發emit事件</button>
</template>
```

```xml
// 父組件
<script>
import TestComponent from "./components/Test.vue";
export default {
  name: "App",
  components: {
    TestComponent,
  },
  setup() {
    const emitHandler = () => {
      alert("接收emit");
    };
    return { emitHandler };
  },
};
</script>

<template>
   <!-- 在父層監聽emit事件 -->
  <TestComponent @call-emit="emitHandler"></TestComponent>
</template>
```

<!--endsec-->

emit 的事件驗證 : 這邊需注意的事，如果 emit 驗證失敗會在 devtools 顯示 warn 提示訊息，但是值也是會傳上去到父層( 簡單來說就算在 emit 觸發失敗，一樣會再父層接收到 emit 事件，並不會因此而停止呼叫！ )。

<!--sec data-title="emit事件驗證範例 :" data-id="section5" data-show=true ces-->

```xml
// 子組件
<script>
export default {
  name: "TestComponent",
  // 改用物件的型式，參數是一個函式
  emits: {
    callEmit(val){
      if (!val) {
        return false;
      }
      return true;
    },
  },
  setup(props, { emit }) {
    const emitHandler = () => {
      emit("callEmit", 0);
    };
    return { emitHandler };
  },
};
</script>

<template>
  <button @click="emitHandler">出發emit事件</button>
</template>
```

```xml
// 父組件
<script>
import TestComponent from "./components/Test.vue";
export default {
  name: "App",
  components: {
    TestComponent,
  },
  setup() {
    // emit驗證失敗，還是會收到回傳值，但多了devtools的warn驗證失敗的提示訊息
    const emitHandler = (val) => {
      alert(`接收emit: ${val}`);
    };
    return { emitHandler };
  },
};
</script>

<template>
  <TestComponent @call-emit="emitHandler"></TestComponent>
</template>
```

<!--endsec-->


## context / expose : <div id="vue-expose"></div>

expose 這個函數，主要是限制該組件會暴露出去的資料，可以限制組件向外暴露的資料來維持組件的封裝性

<!--sec data-title="context / expose範例 : 不使用 expose 函式，在父層透過 ref 就能取得子組件的任何資料" data-id="section6" data-show=true ces-->

```xml
// 子組件
<script>
export default {
  name: "TestComponent",
  setup() {
    const text = "TestComponent";
    return {};
  },
};
</script>
```

```xml
// 父組件
<script>
import { onMounted, ref } from "vue";
import TestComponent from "./components/Test.vue";
export default {
  name: "App",
  components: {
    TestComponent,
  },
  setup() {
    const getDom = ref(null);
    // 成功取得到子組件的資料
    onMounted(() => {
      console.log("取得子組件text資料 :", getDom.value.text);
    });
    return { getDom };
  },
};
</script>
```

<!--endsec-->

<!--sec data-title="context / expose範例 : 當設定 expose 後，父子層只能拿去 expose 所指定的值，其他的值接無法獲取！" data-id="section7" data-show=true ces-->

```xml
// 子組件
<script>
export default {
  name: "TestComponent",
  setup(props, { expose }) {
    const text = "TestComponent";
    const count = 1;
    // 這邊指定義text可暴露在外，count只能在該組件內部使用，外部(父層無法取得expose以外的直)
    expose({ text });
    return { text, count };
  },
};
</script>
```

```xml
// 父組件
<script>
import { onMounted, ref } from "vue";
import TestComponent from "./components/Test.vue";
export default {
  name: "App",
  components: {
    TestComponent,
  },
  setup() {
    const getDom = ref(null);
    onMounted(() => {
      console.log("取得子組件text資料 :", getDom.value.text); // 回傳 : TestComponent
      console.log("取得子組件count資料 :", getDom.value.count);// 回傳 : undefined
    });
    return { getDom };
  },
};
</scrip>
```

<!--endsec-->


## context / attrs : <div id="vue-attrs"></div>

attrs 可以用來簡化 Vue 組件間的傳值，可算是 props 強化版可透過此方法做（ 爺孫組件屬性的傳遞 ）

1. attrs 是用來收集父組件所傳來的屬性，而那些屬性是沒通過 props 所定義的，可以使用 attrs 來取得
2. 如被 props 定義過的屬性，在 attrs 裡就不會出現
3. attrs 除了值之外，也包含 event 事件
4. 需注意 attrs 都有對應的狀態，會隨者自身組件更新而更新，儘量避免解構，如需解構可使用[toRefs]()來操作來重新綁定。

<!--sec data-title="attrs 取得資料範例 :" data-id="section8" data-show=true ces-->

```xml
// 父組件
<template>
  <!-- 在子組件綁定一個click事件以及傳遞屬性 -->
  <TestComponent @click="testHandler" text="測試"></TestComponent>
</template>

<script>
import TestComponent from "./components/Test.vue";
export default {
  name: "App",
  components: {
    TestComponent,
  },
  setup() {
    const testHandler = () => console.log("testHandler");
    return { testHandler };
  },
};
</script>
```

```xml
// 子組件
<script>
import { onMounted } from "vue";
export default {
  name: "TestComponent",
  setup(props, { attrs }) {
    onMounted(() => {
      // 在這邊就能看到除了屬性被傳下來之外，也能取得event事件並呼叫
      console.log("透過 attrs 取得資料", attrs);
      attrs.onClick()
    });
    const text = attrs.text;
    return { text };
  },
};
</script>

<template>
  <p>透過attrs取得資料：{{ text }}</p>
</template>
```

<!--endsec-->

> [!note]
> 以上使用 attrs 接收父組件傳的 attribute，所有的組件預設都會自動繼承自己组件的根元素的屬性[透传 Attribute](https://staging-cn.vuejs.org/guide/components/attrs.html)，如果不想繼承添加 inheritAttrs: false，就能禁用取消自動繼承的問題。

## context / slots : <div id="vue-slots"></div>

slots 可以用來查詢是否有存在 slot(插槽)的值，或者可搭配 render 函式一起使用

<!--sec data-title="slots範例 :" data-id="section9" data-show=true ces-->

```xml
// 父組件
<script>
import TestComponent from "./components/Test.vue";
export default {
  name: "App",
  components: {
    TestComponent,
  },
};
</script>

<template>
  <TestComponent>
    <!-- 傳入slot的值 -->
    <p>測試slot</p>
  </TestComponent>
</template>
```

```xml
// 子組件
<script>
import { onMounted } from "vue";
export default {
  name: "TestComponent",
  setup(props, { slots }) {
    onMounted(() => {
      // 可以查詢到目前有default的slot值
      console.log("透過 slots 取得資料", slots);
    });
    return {};
  },
};
</script>

<template>
  <slot>Default</slot>
</template>
```

<!--endsec-->


## setup - render : <div id="vue-render"></div>

setup 除了 return 值出去，也可以直接回傳 render 的函式搭配一起使用

<!--sec data-title="render : h 參數原先是 render 函式自帶的參數，而到了 Vue3 改為全域導入(自己從 Vue 提取出來)，render()函式在 Vue3 不再自帶參數" data-id="section10" data-show=true ces-->

```xml
// 如果使用render方式撰寫component，副檔名記得改為.js檔，並export出去
import { h } from "vue";
export default {
  name: "TestComponent",
  setup() {
    const text = "這是渲染函式";
    return () => h("div", text);
  },
};
```

<!--endsec-->

## setup - ref、reactive <div id="vue-ref_reactive"></div>

在 Vue2 裡，要綁定值都會寫在 data 裡面，如果不想給 Vue 綁定，都會寫在 data 的外面，到 Vue3 的 setup 函式裡可以很輕鬆定義需要被 Vue 綁定的資料，或不需要被 Vue 綁定的資料，而<span style="color:red;">ref</span>、<span style="color:red;">reactive</span>，就是用來跟 Vue 做響應式綁定的函式。

> [!tip]
> ref : 可以包裝原始型別（ Primitive ）的值之外，也可以來包裝物件或陣列，如果包裝的類型為基本類型，則是透過defineProperty()的get()和set()來做響應式，如果是物件或陣列型別，則透過reactive轉為proxy()代理對象，使用 ref 包裝過的資料，需要在後面加上.value，才能取得被 ref 包裝的值！

<!--sec data-title="ref 範例 :" data-id="section11" data-show=true ces-->

```xml
import { ref } from "vue";
export default {
  name: "App",
  setup() {
    const num = ref(0);
    setTimeout(() => num.value++, 1000);

    // 定義完ref之後的值，需要返回出去才能在模板時候，在模板使用不需要加上.value
    return { num };
  },
};
```

<!--endsec-->

ref 存取 DOM 元素 : 在 setup()函式裡，沒有 this.$refs(也沒有 this)，所以綁定 DOM 的方式

<!--sec data-title="ref綁定DOM範例 :" data-id="section12" data-show=true ces-->

```xml
<template>
  // 要與要綁定的變數同名！ ---- (3)
  <div ref="getDom"></div>
</template>

<script>
import { ref, onMounted } from "vue";
export default {
 name: "App",
 setup() {

   // 聲明一個要被綁定的dom名稱 ---- (1)
   const getDom = ref(null);

   onMounted(() => {
    // 當生命週期onMounted的時候就能看到，DOＭ已被getDom存取 ---- (4)
     console.log("getDom -->", getDom);
   });

   // 並return出去，在模板中需要定義ref="getDom"同名的屬性 ---- (2)
   return { getDom };
 },
};
</script>
```
<!--endsec-->


reactive : <span style="color:red;">reactive()</span> 是 ref()以外，另一個可以包裝成響應式物件的函式，包裝過後的<span style="color:red;">reactive()</span>會回傳被 Proxy 所代理的物件，<span style="color:red;">reactive()</span>函式只能包裝<span style="color:red;"> 物件、陣列 </span>，使用上不需要加上.value，就如取得物件實字的 value 一樣。

<!--sec data-title="reactive範例 :" data-id="section13" data-show=true ces-->

```js
import { reactive, onMounted } from "vue";
export default {
  name: "App",
  setup() {
    const data = reactive({ num: 1 });

    onMounted(() => {
      // 不需要加上.value，取值方式就與物件實字方式一樣！
      console.log("data -->", data.num);
    });
    return { data };
  },
};
```

<!--endsec-->

<span style="color:red;">reactive()</span> 可以包裝物件跟陣列，所以我們也可以利用解構的方式，方便取的屬性值，如果使用解構的方式取直，會把值從響應式的狀態抽取出來 :

<!--sec data-title="reactive 解構時會解除響應式 :" data-id="section14" data-show=true ces-->

```xml
<script>
import { reactive } from "vue";
export default {
  name: "App",
  setup() {
    const data = reactive({ num: 1 });
    // 這邊使用解構得方式，可以看到在案+1的時候，畫面卻沒更新
    return { ...data };
  },
};
</script>

<template>
  <div>{{ num }}</div>
  <button type="button" @click="num++">+1</button>
</template>
```

<!--endsec-->

想要解決以上的問題看使用 toRefs()函式：

<!--sec data-title="使用toRefs，解決reactive解構時，響應式的問題 :" data-id="section15" data-show=true ces-->

```xml
<script>
import { reactive, toRefs } from "vue";
export default {
  name: "App",
  setup() {
    const data = reactive({ num: 1 });

    // or

    // const refData = toRefs(data);

    // 使用toRefs()的方式，可以看到在案+1的時候，畫面有更新
    return { ...toRefs(data) /*  or ...refData  */ };
  },
};
</script>

<template>
  <div>{{ num }}</div>
  <button type="button" @click="num++">+1</button>
</template>
```

<!--endsec-->

## methods : <div id="vue-methods"></div>

在 setup()函式裡，不在提供 "method" 屬性，而是直接在 setup()裡定義一個 function (表達式或陳述式)，如果函式不需要在模板內使用可以不用 return 回去！

<!--sec data-title="methods範例 :" data-id="section16" data-show=true ces-->

```xml
export default {
    setup(props,{ attrs, slots, emit, expose }) {
        // 表達式
        const call1 = () => console.log('Hi')

        // or

        // 陳述式
        function call2(){
            console.log('Hi')
        }

        // 如果模板內需要使用，要return回去！
        return { call1 , call2}
    }
}
```

<!--endsec-->


## computed : <div id="vue-computed"></div>

使用 computed 需要從 vue 提取出來，並使用函數式的方式使用。

<!--sec data-title="computed範例 :" data-id="section17" data-show=true ces-->

```js
import { ref ,computed } from 'vue'
export default {
  setup() {
    const num = ref(0)
    const double = computed(() => num.value * 2)
    return { double }
  }
}
```

<!--endsec-->

## watch / watchEffect ( Vue3 新增 ) : <div id="vue-watch_watchEffect"></div>

使用 watch / watchEffect 的方式，就跟 computed 一樣需要從 vue 提取出來，並函數式的方式使用，使用方式與 Vue2 的寫法稍微不同。


> [!note]
>  watch : 可以偵聽 <span style="color:red;">單個資料</span> 或 <span style="color:red;">多個資料</span> (把需要監聽的資料放入陣列裡)<br>
> 參數為：
  1. 第一個參數 : 要監控的值
  2. 第二個參數 : 當值被改變時觸發的callback函式，callback函式自帶(原始值/已變更的直)
  3. 第三個參數 :  { deep: true } 深度檢查的時候，如物件包物件（嵌套對象），預設為false

<!--sec data-title="watch範例 :" data-id="section18" data-show=true ces-->

```js
// 偵聽一個資料
import { ref, watch } from "vue";
export default {
  setup() {
    const num = ref(0);

    // 使用watch監聽
    watch(num, (newVal, oldVal) => {
      console.log("newVal :", newVal, " ", "oldVal :", oldVal);
    });

    // 使用setTimeout方式來測式，一秒過後watch會偵聽改動部分
    setTimeout(() => {
      num.value++;
    }, 1000);

    return {};
  },
};
```

```js
// 偵聽多個資料
import { ref ,watch  } from "vue";
export default {
  name: "App",
  setup() {
    const text1 = ref("");
    const text2 = ref("");

    watch([text1, text2], (newVal, oldVal) => {
      // 回傳陣列的直
      console.log("newVal : ", newVal, "", "o :", oldVal);
    });

    text1.value = 1;
    text2.value = 2;
    return {};
  },
};
```

<!--endsec-->

1. 如果是監聽<span style="color:red;">reactive（響應式）</span>的資料，第一個參數需要透過 return 函式 的方式監聽，這邊需要注意的事，監聽<span style="color:red;">reactive</span>的其中一個屬性，如果沒使用 return 函式 的方式去監聽，會沒有反應！
2. 直接監聽整個<span style="color:red;">reactive</span>資料(需加上 deep：true 才會有反應)，會發現第二參數回傳的 newValue、oldValue 值都顯示一樣！！

<!--sec data-title="監聽reactive範例 :" data-id="section19" data-show=true ces-->

```js
import { reactive, watch } from "vue";
export default {
  name: "App",
  setup() {
    const data = reactive({ num: 1 });

    // 這邊沒有反應
    watch(data.num, (newVal, oldVal) => {
      console.log("watch-1 newVal : ", newVal, "", "o :", oldVal);
    });

    // 回傳的參數都會一樣
    watch(data, (newVal, oldVal) => {
      console.log("watch-2 newVal : ", newVal, "", "o :", oldVal);
    });

    // 正確寫法為
    watch(
      () => data.num,
      (newVal, oldVal) => {
        console.log("watch-3 newVal : ", newVal, "", "o :", oldVal);
      }
    );

    data.num++;
    return {};
  },
};
```

<!--endsec-->

<span style="color:red;">watchEffect</span> 與 watch 一樣都是在監控值，然後執行裡面的程式碼，但比較不同的是<span style="color:red;">watchEffect</span>不用特地指定要監控的資料，而是當 setup()函式內部 callback 對應的響應式資料被更新時，就會觸發( 簡單來說監控 setup 裡面的值被更新時，都會觸發 )，另外<span style="color:red;">watchEffect</span>是在 setup()函式剛被建立後就會<span style="color:red;">立即執行一次</span>！

<!--sec data-title="watchEffect範例 :" data-id="section20" data-show=true ces-->

```js
import { ref, watchEffect } from "vue";
export default {
  name: "App",
  setup() {
    const num = ref(0);

    // setup剛被建立完，立即執行一次
    watchEffect(() => console.log("num", num.value));

    // 過一秒後更改num值，會在觸發一次watchEffect
    setTimeout(() => num.value++, 1000);

    return {};
  },
};
```

<!--endsec-->


如果不是使用 <span style="color:red;">ref</span> 或 <span style="color:red;">reactive</span> 函式把值包裝起來的變數，當 setup()剛被建立時會執行一次 <span style="color:red;">watchEffect</span> ，但在更新值的時候就不再觸發！

<!--sec data-title="不是響應式資料更新時，watchEffect不會作動 :" data-id="section21" data-show=true ces-->

```js
import { watchEffect } from "vue";
export default {
  name: "App",
  setup() {
    let num = 0;

    // 會立即執行一次
    watchEffect(() => console.log("num", num));

    // 更改的值不是響應式，所以不再觸發watchEffect
    setTimeout(() => num++, 1000);

    return {};
  },
};
```

<!--endsec-->

> [!note]
> 以上 <span style="color:red;">watchEffect</span>總結：
  1. 不需要特定傳入監控的資料
  2. setup()被建立完，立即執行
  3. 只能獲取變化後的值，無法取的變化前的值
