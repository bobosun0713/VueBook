# setup

這邊開始介紹一下 setup ( Composition API ) 與 Options API 不一樣的地方，在 setup()裡通常都有包含 Lifecycle Hooks( 生命週期鉤子 )、狀態資料等，但有些程式邏輯不一定都要在這裡面做定義，可以透過引入( import )的方式來使用，但透過 setup（）函式需要透過 return 回傳回去。

```javascript=
// 定義玩參數要回傳出去，才能在template模板使用！
export default {
    setup(props) {
        const text = '文字...'
        return { text }
    }
}
```

> 在這邊需要中在 setup()函式裡面，避免使用"this"，會找不到組建實例，如同[生命週期的範例](src/../03.md)，setup()函式的調用在 beforeCreate、created 的前面，簡單來說 setup()函式在組件解析之前就被調用，所以"this"會無法在 setup 中獲取！！

## 參數 props / context

setup()函式被呼叫時，會接收兩種參數 1.props 2.context

### props : <div id="vue-props"></div>

> 1. 調用 props 時需要透過 props 來取的相對應 props 的內容。
> 2. props 可以在 setup()函式中解構出來，但是會消除 prop 響應式特性，如果需要解構，需使用[toRefs]()來操作。

```
export default {
    props:{
        type: String,
        default:"normal"
    },
    setup(props,context) {

        console.log(props,type)
        return {}
    }
}
```

### context : <div id="vue-context"></div>

> context 為 setup()函式第二個參數 Object，可以透過解構的方式取出 attrs、slots、emit、expose

```
export default {
    setup(props,{ attrs, slots, emit, expose }) {
        console.log('emit => ',emit)
        console.log('attrs => ',attrs)
        return {}
    }
}
```

## setup - methods、computed、watch / watchEffect <div id="vue-methods"></div>

### methods :

在 setup()函式裡，不在提供 "method" 屬性，而是直接在 setup()裡定義一個 function (表達式或陳述式)，如果函式不需要在模板內使用可以不用 return 回去！

```javascript=
export default {
    setup(props,{ attrs, slots, emit, expose }) {
        // 表達式
        const call1 = () => console.log('Hi')

        // or

        // 陳述式
        function call2(){
            console.log('Hi')
        }

        // 如果模板內需要使用，要return回去！
        return { call1 , call2}
    }
}
```

### computed :

使用 computed 需要透過解構的方始，從 vue 提取出來，並使用函數式的方式使用。

```javascript=
import { ref ,computed } from 'vue'
export default {
  setup() {
    const num = ref(0)
    const double = computed(() => num.value * 2)
    return { double }
  }
}
```

### watch / watchEffect :

使用 watch / watchEffect 的方式，就跟 computed 一樣需要從 vue 提取出來，並函數式的方式使用，使用方式與 Vue2 的寫法稍微不同。

> watch : 可以偵聽 <span style="color:red;">單個資料</span> 或 <span style="color:red;">多個資料</span> (把需要監聽的資料放入陣列裡)<br>

```
參數為：
1. 第一個參數 : 要監控的值
2. 第二個參數 : 當值被改變時觸發的callback函式，callback函式自帶(原始值/已變更的直)
3. 第三個參數 :  { deep: true } 深度檢查的時候，如物件包物件（嵌套對象），預設為false
```

```javascript=
// 偵聽一個資料
import { ref, watch } from "vue";
export default {
  setup() {
    const num = ref(0);

    // 使用watch監聽
    watch(num, (newVal, oldVal) => {
      console.log("newVal :", newVal, " ", "oldVal :", oldVal);
    });

    // 使用setTimeout方式來測式，一秒過後watch會偵聽改動部分
    setTimeout(() => {
      num.value++;
    }, 1000);

    return {};
  },
};
```

```javascript=
// 偵聽多個資料
import { ref ,watch  } from "vue";
export default {
  name: "App",
  setup() {
    const text1 = ref("");
    const text2 = ref("");

    watch([text1, text2], (newVal, oldVal) => {
      // 回傳陣列的直
      console.log("newVal : ", newVal, "", "o :", oldVal);
    });

    text1.value = 1;
    text2.value = 2;
    return {};
  },
};
```

> 1. 如果是監聽<span style="color:red;">reactive（響應式）</span>的資料，第一個參數需要透過 return 函式 的方式監聽，這邊需要注意的事，監聽<span style="color:red;">reactive</span>的其中一個屬性，如果沒使用 return 函式 的方式去監聽，會沒有反應！
> 2. 直接監聽整個<span style="color:red;">reactive</span>資料(需加上 deep：true 才會有反應)，會發現第二參數回傳的 newValue、oldValue 值都顯示一樣！！

```javascript=
import { reactive, watch } from "vue";
export default {
  name: "App",
  setup() {
    const data = reactive({ num: 1 });

    // 這邊沒有反應
    watch(data.num, (newVal, oldVal) => {
      console.log("watch-1 newVal : ", newVal, "", "o :", oldVal);
    });

    // 回傳的參數都會一樣
    watch(data, (newVal, oldVal) => {
      console.log("watch-2 newVal : ", newVal, "", "o :", oldVal);
    });

    // 正確寫法為
    watch(
      () => data.num,
      (newVal, oldVal) => {
        console.log("watch-3 newVal : ", newVal, "", "o :", oldVal);
      }
    );

    data.num++;
    return {};
  },
};
```
