# Vue Router
這邊簡單介紹一下 Vue3 使用 router 方式，其流程與 Vue2 相同，只是差一點在於 router 版本及一些設定的調整。

## 安裝 Vue Router
目前使用 vite 開發 Vue 專案時，只有安裝基本的 Vue 配置外，如果需要安裝其他 Library 時，需要手動安裝！

<!--sec data-title="Vue Router 安裝流程 :" data-id="section1" data-show=true ces-->

1. 安裝流程 : 這邊需要注意 Vue3 因底層核心得改寫，所以需要安裝 V4 的版本，如果安裝到 V3 版本使用上會出錯誤
   ```
   npm install vue-router@4
   ```

2. 安裝完以後，首先要先去 App.vue 新增 \<router-view> 標籤，這邊 \<router-view> 會是所有 Router 初始進入點
   ```
   // App.vue
   <template>

    // Vue3 新增 Fragment 特性之後，可以有很多根節點在 template 上!
    <router-view></router-view>

   </template>
   ```
 3. 以上做完現在可以規劃一下 router 路徑，以下為專案的配置 (僅供參考，可依專案自行調整)
    ```
    |- src 
        |- assets     // 資源目錄
        |- components // 組件目錄
        |- router     // 路由目錄
        |- view       // 頁面目錄
        |- App.vue    // 入口
    ```  
 
 4. 建立 router 檔案位置 : 先在 src 資料夾底下新增 index.js 來設置 router 的入口
    ```js
    // router/index.js
    import { createRouter, createWebHistory } from 'vue-router';
    import Home from '@/views/home.vue'; // 這邊使用別名方式引入，如設定可以參照第一篇的『 Vite 路徑別名設置 』 教學使用

    const router = createRouter({
    history: createWebHistory(),
    routes: [
        {
        path: '/',
        /**
        * component 可透過 "直接引入" 的方式或使用 "動態引入" 的方式
        * 直接引入方式 : 在於一開始就需要先讀取該.vue檔的檔案、也就是第一次執行時就載入檔案，一開始會造成網頁負擔多一點
        * 動態引入方式 : 在於一開始不會預先載入所有 component 的檔案，減少第一次載入時的大小，來加快網頁的渲染，網站規模越大時對整體載入速度有幫助，但問題容易造成 request 數量增加
        * 兩種都可以使用，主要看專案的規劃！
        */
        component: Home // () => import('@/components/HelloWorld.vue')
        }
    ]
    });
    export default router;
    ```

3. 接著在 main.js 引入 router 加入至 Vue 裡 : 
   ```js
   import { createApp } from 'vue';
   import App from '@/App.vue';
   import router from '@/router';
   createApp(App).use(router).mount('#app');
   ``` 

4. 執行 vite 就能看到 畫面就是我們設定的 router 的頁面。
   > 注意 path 是 ／ 時，也就我們首次進入點的頁面也可以當作為首頁 
<!--endsec-->


## Router 模式 ( hash 、 webHistory )
這邊需注意在 router@3 版本中 "模式名稱" 為 mode，而到了 router@4 時，改為 history

- hash
  1. 在 Hash 是透過 ＃(井號）來對應頁面的位置，#號在網頁來說代表錨點的意思，可透過 a 標籤的 herf 來指定到某個標籤的地方，同時也會增加瀏覽器的紀錄，在透過瀏覽器的上下頁來切換不同的位置，也不會引發重新讀取的問題。
  2.  在 # 字號後面出現的字元，都會被瀏覽器識為 "位置符號"，也就是說 URL 有多少個 #號 ，從網址中第一個 #號 的出現到後面所有的字元，都會被瀏覽器識為 “位置符號”，也不會發送到 server 端去
  3.  使用 hash 模式，不利於 SEO : 以上面的敘述，＃號 後面字元被代表 "位置符號"，也就是如果透過 hash 模式切換頁面，在搜尋引擎來說都是通個頁面這樣並不利於網站 SEO  
    ```js
    //  Hash
    import { createRouter, createWebHashHistory } from 'vue-router';
    import Home from '@/views/home.vue';
    const router = createRouter({
        history: createWebHashHistory(),
        routes: [
            {
            path:'/' // http://localhost:5173/#/
            component: Home 
            },
            {
            path:'/product' // http://localhost:5173/product#/
            component: Home 
            },
        ]
    });

    export default router;
    ```

- history
  1. 主要原理是透過 HTML5 提供的 History API，使得前端在瀏覽器發送 Request 時，透過攔截請求再返回其資源 透過 ( pushState、replaceState 來更新 )
  2. 設定方式與 hash 模式相同，只需要把 createWebHashHistory 更改為 createWebhHistory 即可
  3. 這邊的 URL 的變更方式與 hash 模式不同， History模式 URL 的變更都會項後端發送 Request 請求
     > 這邊需注意，如果專案是使用 "後端框架" 來導入 vue，需要在後端重新設定 route 的規則，使 route 統一指向 Vue Router
  4. 因為使用 history 模式，不會產生 # 號，也有利於網站 SEO
    ```js
    //  history
    import { createRouter, createWebHistory } from 'vue-router';
    import Home from '@/views/home.vue';
    const router = createRouter({
        history: createWebHistory(),
        routes: [
            {
            path:'/' // http://localhost:5173/
            component: Home 
            },
            {
            path:'/product' // http://localhost:5173/user
            component: Home 
            },
        ]
    });

    export default router;
    ```
